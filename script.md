## Black box testing
Начинаем с [этого кода](https://github.com/mate-academy/js-testing/tree/4435b647eac1dc61b8474f3e6b5dd3dfbb2f7a7e/src)

- Теперь давайте посмотрим насколько наши тесты нам помогают.
- Сломаем реализацию заменив на `.padStart(3, '0')`
- Теперь у нас не проходят несколько тестов
- Но прямо в коде мы не видим что именно не там (экстеншен не показывает ошибки в соответствующих строках из-за цикла)
- Справа мы видим только названия тестов
- Кстати название теста не обязательно начинать с `should`, мы можем просто писать `returns a 4-digit string for ${value}` так короче
- но мы всё равно не знаем подробностей ошибки
- Чтобы их увидеть мы можем запустить тесты в терминале (открываем терминал снизу, чтобы было видно и боковую панель с jest и результаты тестов внизу)
- Мы видим что результаты отличаются!
- Проблема в том что сейчас в тестах у нас всё ещё используются случайные данные и поэтому они всё ещё работают непредсказуемо
- Нам нужно избавиться от случайных данных везде, где это возможно
- Поэтому мы убираем цикл и пишем несколько отдельных тестов 
  - `returns 4-digit secret from a 4-digit` (0.1234 => '1234')
  - `adds a leading 0 to a 3-digit value` (0.567 => '0567')
  - `does not use 2-digit value for the secret` (0.12, 0.9876 => '9876')
  - `does not use a value with repeated digits for the secret`
    (0.55123, 0.1231, 0.4037 => '4037')
- Теперь все тесты работаю абсолютно стабильно и каждый проверяет именно то что в нём написано
- Но это только до тех пор пока мы не решим отрефакторить код
  ```js
  function generateSecret() {
    const digits = '0123456789'.split('');

    digits.sort(() => Math.random() - 0.5);

    return digits.slice(-4).join('');
  }
  ```
- Теперь наши тесты сломаны, поскольку поменялась логика использования `Math.random`
- Но это же не означает, что функция работает неправильно
- Поэтому наши тесты, не помогают а только 
- А вот исходные тесты которые работают с реальными результатами (без моков)тестируют нашу функцию без привязки к реализации (как чёрный ящик), и соответствуют нашему сценарию использования (ровно 4 неповторяющиеся цифры)
- Ну а чтобы они были более точными мы можем генерировать 10-20 значение и запускать тесты для каждого из них проверяя его на 4 уникальные цифры (а не на конкретное значение)
